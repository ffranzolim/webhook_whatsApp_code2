import { MessageModel } from '../message/messageModel';
import { Logger } from '../../common/definitions';
import { MessagePayload } from '../message';
/**
 * Super class for concrete context classes used to invoke custom components
 * and event handlers
 */
export declare abstract class BaseContext {
    protected readonly _request: any;
    protected readonly _response: any;
    protected readonly _logger: Logger;
    /**
     * @param {object} request - invocation request payload
     * @param {object} response - initial response payload
     * @param {Function} [validationSchema] - callback returns a schema for request body validation
     */
    constructor(request: any, response: any, validationSchema?: (joi: any) => any);
    /**
     * Retrieves the request object.
     * @return {object} The request object.
     */
    getRequest(): any;
    /**
     * Retrieves the response object.
     * @return {object} The response object.
     */
    getResponse(): any;
    /**
     * Retrieves the logger object.
     * @return {object} The logger object.
     */
    logger(): Logger;
    /**
     * Retrieves the logger object.
     * @return {object} The logger object.
     * @deprecated use logger() function instead
     */
    getLogger(): Logger;
    /**
     * Read or write variables defined in the current flow.
     * It is not possible to change the type of an existing variable through
     * this method.  It is the caller's responsibility to ensure that the
     * value being set on a variable is of the correct type. (e.g. entity,
     * string or other primitive, etc).
     * <p>
     * A new variable can be created.  However, since the variable is not
     * defined in the flow, using it in the flow subsequently may be flagged
     * for validation warnings.
     * </p>
     * This function takes a variable number of arguments.
     * <p>
     * The first form:
     * variable(name);
     * reads the variable called "name", returning its value.
     * The name could be in the form of &lt;scope&gt;.&lt;variableName&gt;.  For example, a variable firstName in the
     * profile scope needs to be retrieved as variable("profile.firstName").
     * </p>
     * The second form:
     * variable(name, value);
     * writes the value "value" to the variable called "name".
     *
     * @param {string}  name - The name of variable to be set or read
     * @param {*} [value] - value to be set for variable
     * @example
     *  let firstName = conversation.variable("profile.firstName");
     *  let lastName = conversation.variable("profile.lastName");
     *  conversation.variable("fullName", firstName + ' ' + lastName);
     */
    variable(name: string, value?: any): any | this;
    /**
     * Returns the value of a context or user variable
     * @return {object} variable value
     * @param {string} name - name of the variable
     */
    getVariable(name: any): any;
    /**
     * Sets the value of a context or user variable
     * @param {string} name - name of the variable
     * @param {object} value - value of the variable
     */
    setVariable(name: any, value: any): this;
    /**
     * Get translated string using a resource bundle key defined in the skill.
     * @return {string} resource bundle freemarker expression that will be resolved when event handler or custom component response is
     * received by dialog engine
     * @param {string} rbKey - key of the resource bundle entry defined with the skill that should be used to translate
     * @param {string} rbArgs - substitution variables
     */
    translate(rbKey: string, ...rbArgs: string[]): string;
    /**
     * Return the channel conversation type
     * @return {string} the channel type
     */
    getChannelType(): string;
    /**
     * Returns the MessageModel class for creating or validating messages to or from bots.
     * @see MessageModel.js
     * @return {MessageModel} The MessageModel class
     */
    getMessageModel(): typeof MessageModel;
    /**
     * Creates a message payload object
     * @param {object} payload - can take a string payload, an object payload or a MessageModel payload.  A string or object
     * payload will be parsed into a MessageModel payload.  If the MessageModel payload has a valid common message format,
     * then reply will use it as messagePayload, else it will use the payload to create a rawConversationMessage as messagePayload.
     */
    constructMessagePayload(payload: any): MessagePayload;
}
